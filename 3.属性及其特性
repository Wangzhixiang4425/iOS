栈
  当程序执行某个方法或函数时，会从内存中名为栈(stack)的区域中分配一块内存空间，这块内存空间称为帧(frame)。
  帧负责保存程序在方法内声明的变量的值。在方法内声明的变量称为局部变量。
  当某个应用启动并运行 main 函数时，它的帧会被保存在栈的底部。
  当 main 调用 另一个 方法（ 或 函数） 时，这个方法（或函数）的帧会压入栈的顶部。
  被调用的方法还可以再调用其他方法，依此类推，最终依此类推，最终会在栈中形成一个塔状的帧序列。
  当被调用的方法（或函数）结束时，程序会将其帧从栈顶“弹出”并释放。
  如果同一个方法再次被调用，则应用会创建一个全新的帧，并将其压入栈的顶部。

任何属性都可以有一组特性，用于描述相应存取方法的行为。这些特性需要写在小括号里，并跟在@property 后面，示例如下：
  @property (nonatomic, readwrite, strong)NSString *itemName;
  任何特性都有三个特性，每个特性都有多种不同的可选类型。在这些可选类型中，有一种是默认的。如果属性的某个特性使用默认类型，就可以在声明该特性时忽略这项特性。

多线程特性
  多线程特性有两种可选类型：nonatomic和 atomic
  nonatomic 不是默认类型，所以在声明属性时，必须明确地写出nonatomic

读/写特性
  读写特性也有两种可选类型：readwrite 和 readonly
  编译器会为具有readwrite特性的属性生成存方法和取方法，如果是 readonly 类型，则会只生成取方法。第二个特性的默认类型是 readwrite。

内存管理特性
  内存管理特性有四种可选类型：strong、weak、copy 和 unsafe_unretained。这些类型决定相应的实例变量如何将如何引用对象。
  
  对于不指向任何对象的属性（如 int），不需要做内存管理，这时应该选用unsafe_unretained，它表示存取方法会直接为实例变量赋值。
  Apple 引入 ARC 前曾用assign 表示这种特性。unsafe_unretained中的“unsafe”可能会误导读者。该类型的“不安全”是相对于弱引用而言的。
  与弱引用不同，unsafe_unretained类型的指针指向的对象被销毁时，指针不会自动销毁设置为 nil，而是成为空指针，因此不安全。
  但是处理非对象属性时，是不会出现空指针问题的。unsafe_unretained是非对象属性的默认值。
  
  对于指向Objective-C对象的属性，四种类型都有可能。默认是 strong 类型，但是通常程序员会明确写出strong。
  
  当某个属性是指向其他对象的指针，而且该对象的类有可修改的子类（NSMutableString 和 NSMutableArray）时，应该将属性的内存管理特性设置为 copy。
  这样做的原因是，如果属性指向的对象的类有可修改的子类，那么该属性可能会指向可修改的子类对象，同时该对象可能会被其他拥有者修改。
  因此，最好先复制该对象，然后再将属性指向复制后的对象。
  //凡是可以使用 NSString 对象的地方，也可以使用 NSMutableString对象
  copy 方法返回的是拥有强引用特性的指针，而收到 copy消息的NSString对象不会发生任何变化：
    该对象不会获得也不会失去拥有者，其数据也不会发生任何变化。
  只有可变对象应该设置为 copy，而复制不可变对象会浪费内存空间——不可变对象不会发生上述问题，因为任何对象都无法修改他们。
  为了避免不必要的复制，向不可变对象发送 copy 消息时，会返回一个指向自己（仍然不可变）的指针

注意，如果既覆盖了存方法，又覆盖了取方法（或者为只读属性覆盖了取方法），那么编译器就不会再自动创建相应的实例变量了。如果需要实例变量，就必须明确声明。



属性合成
  在头文件中声明属性时，只会生成存取方法的声明。为了让属性生成实例变量并实现存取方法，该属性必须被合成。
  通常情况下，编译器会自动合成属性并生成默认的实例变量和存取方法。如果需要自定义属性的合成方式，可以在实现文件中使用@synthesize 指令：

@implementation Person
//创建存取方法，方法名是age 和 setAge
//同时创建实例变量_age
@synthesize age = _age;
@end

以上代码与编译器自动合成的效果相同。
赋值号左边的 age 表示需要创建存取方法，方法名是 age 和setAge：。
右边的_age表示需要创建实例变量，变量名为_age。
也可以不写变量名，这样实例变量的变量名会和方法名相同：
@synthesize age;
//和以下语句效果相同
@synthesize age = age;
有时我们不希望属性自动生成实例变量和存取方法，同时覆盖存方法和取方法编译器就不会为类自动合成实例变量
